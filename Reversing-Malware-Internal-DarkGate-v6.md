---
title: "Reversing Malware Internals: DarkGate v6"
date: 2024-09-08T00:00:00+05:45
# post image
image: "https://github.com/user-attachments/assets/92abfa0a-4610-4045-b212-4ad4e3a36779"
# author
author: "Venus Chhantel"
# post type (regular/featured)
type: "regular"
# meta description
description: "DarkGate is a sophisticated and versatile malware that has been active since 2017, which operates on a malware-as-a-service (MaaS) model. DarkGate is known for its ability to evasion techniques."
# post draft
draft: false
---

{{< toc >}}

## Execution Flow

The execution flow of DarkGate v6 is illustrated in the figure below. The breakdown of execution flow is in the technical analysis section.

{{< image src="https://github.com/user-attachments/assets/92abfa0a-4610-4045-b212-4ad4e3a36779" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

## Technical Analysis

### Initial Stager

#### URL Obfuscation

Typically, PDFs delivered via phishing emails serve as the initial stager for the Darkgate malware. In this particular PDF sample, there was a "Download" button that, when clicked, will open a URL, which seems like a tracking URL from ClickCease as shown below.

{{< image src="https://github.com/user-attachments/assets/b15fba50-e280-4ccf-9116-4acfd4f4cf58" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Actually, the malicious URL is hidden using a tracking URL from ClickCease. Darkgate abused Ads technologies to make the URL appear legitimate and to bypass security tools that only verify the domain of a URL to assess its malicious nature. Clicking the download button on PDF will redirects the user to a malicious URL, initiating the download of the next stager, an MSI file. 

<br>

### Second Stager

The MSI file was downloaded after clicking the Download button on PDF file, which on examination using Orca revealed the presence of two binary files within the MSI: a DLL file (bz.CustomActionDLL) and a CAB file (bz.WrapperSetupProgram) as indicated by their signature.

{{< image src="https://github.com/user-attachments/assets/8fd4cddb-830b-4bc1-9567-de34f14bb043" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Additionally, the CAB file header point out presence of three files under it; CoreFoundation.dll, iTunesHelper.exe and sqlite3.dll as can be seen below.

{{< image src="https://github.com/user-attachments/assets/5d2b1622-ab29-494c-87b0-2b65031642a4" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Further inspection using Orca indicated that the CustomAction section is configured to execute the DLL file (bz.CustomActionDll).

{{< image src="https://github.com/user-attachments/assets/42d747f7-6f7c-43b7-9124-2d26556ec4ee" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### CAB Extraction & Execution by DLL

Since the DLL will be executed first, the DLL file (bz.CustomActionDll) was analyzed using IDA. The analysis revealed that the DLL retrieves the path to the %TEMP% directory (C:\Users\<USER>\AppData\Local\Temp) and appends ‘MW-<<UUID>>’ to this path. It then creates a directory with this name within the %TEMP% directory, as shown below.

{{< image src="https://github.com/user-attachments/assets/f3cf1b29-3a4e-4716-a1e6-03a5ca34006b" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The DLL proceeds to extract those three files of the CAB file under the abovementioned directory using ‘expand.exe’ binary. To achieve this, it first retrieves the path to System32 by calling SHGetFolderPathW with the second argument 37, corresponding to the CSIDL_SYSTEM constant (C:\Windows\System32). It then appends ‘EXPAND.EXE’ to construct the full path to the binary. The DLL also appends the parameters ‘-R files.cab -F:* files’ to specify the extraction operation via ‘expand.exe’ binary . The extraction process is executed by calling ShellExecuteExW with the constructed command.

{{< image src="https://github.com/user-attachments/assets/11229504-59e9-47e1-83c9-6195908ae52c" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The three files extracted from CAB file can be seen below.

{{< image src="https://github.com/user-attachments/assets/e25a1783-88ae-4ab5-9197-bcad013016a0" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Following the extraction of the CAB file contents, the DLL utilizes a similar approach to retrieve the path to the ‘icacls.exe’ binary from the C:\Windows\System32 directory. This executable is then run using ShellExecuteExW. By executing the ‘icacls.exe’ binary, the DLL sets the directory integrity level to high, thereby evading detection. This tactic makes it more difficult for security tools operating at a lower integrity level to detect and remove the directory and its contents.

{{< image src="https://github.com/user-attachments/assets/c4916440-fd51-4d0a-b99b-315aeed5ae09" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Finally, the DLL execute the iTunesHelper.exe by calling ShellExecuteExW as can be seen below, which is one of the content of the CAB file that was previously extracted via ‘expand.exe’.

{{< image src="https://github.com/user-attachments/assets/c2c5b33a-ef48-4ff8-bca3-60e1eac1a99c" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

### Third Stager

#### DLL SideLoading

The DLL at last executed iTunesHelper.exe as covered in above section. This execution appears to be part of a DLL sideloading technique, where a legitimate executable is used to load and execute a trojanized DLL by hijacking the DLL search order. The DLL search order is shown in image below. 

{{< image src="https://github.com/user-attachments/assets/8f45301d-d236-4670-8bac-cfffa7e3c83a" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

From the previously extracted 3 files, iTunesHelper.exe is a legitimate executable. The CoreFoundation.dll is a trojanized DLL that gets loaded by the legitimate iTunesHelper.exe due to the DLL search order hijacking. The file sqlite3.dll appears to be an encrypted binary as can be seen below. The ‘sqlite3.dll’ is likely to be decrypted by the trojanized DLL after sideloading.

{{< image src="https://github.com/user-attachments/assets/0e911269-7ec2-40be-89ad-0b699d891ba4" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### Decrypting Files from Encryted Dropper

Additionally, there are lots of repeating text ‘VzXLKSZE’ under the sqlite3.dll file as seen above. That string looked like XOR key, where the contents of sqlite3.dll will perform XOR operation with that key likely to output a new PE (executable) file. This is one of obfuscation technique seen in the wild.

To verify this hypothesis, the CoreFoundation.dll was loaded into IDA. Analysis confirmed that the contents of sqlite3.dll were indeed subjected to an XOR operation using the string 'VzXLKSZE' as the XOR key. The resulting payload from the XOR operation is allocated memory using VirtualAlloc, mapped, and then executed.

{{< image src="https://github.com/user-attachments/assets/f5fa943b-c9f8-482a-b1f4-8b0814f8113e" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### Drop Next Stager Files

A quick XOR operation performed on sqlite3.dll with the ‘VzXLKSZE’ key on CyberChef revealed the result to be a 64-bit executable file.

{{< image src="https://github.com/user-attachments/assets/890a180e-a71e-41e4-9f48-fadbb3100918" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The above resulting executable was saved from CyberChef and loaded in IDA. It was found that this decrypted executable will again use the sqlite3.dll to decrypt next stager files: Autoit3.exe, script.a3x and test.txt. Those file will be dropped under C:\temp. Then, the script.a3x Autoit script will be executed with Autoit3.exe binary, after the encrypted Autoit3.exe binary with XOR operation using ‘VzXLKSZE’ as key.

{{< image src="https://github.com/user-attachments/assets/664183e6-888a-45e2-95e5-975e82072db8" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The sqlite3.dll file have ‘delimitador’ text inside it as marker to separate those file, which can be seen below.

{{< image src="https://github.com/user-attachments/assets/694d46e2-1017-4f65-b834-ac21cfa6e34e" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

### **Fourth Stager**

#### Decrypting Obfuscated Autoit (.au3) Script

The files dropped under C:\temp can be seen below. 

{{< image src="https://github.com/user-attachments/assets/03bb7174-ade2-4d3d-b2ed-af6395131b91" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The Autoit3.exe is legitimate binary which will execute the script.a3x script. So, the analysis was shifted to script.a3x. The original script from script.a3x was extracted using Autoit Extractor as can be seen below. The extracted output was saved to a file.

{{< image src="https://github.com/user-attachments/assets/870e51db-6b2f-4273-b6df-c3c49d8d26f7" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The output from Autoit Extractor is obfuscated as can be seen below.

{{< image src="https://github.com/user-attachments/assets/6f6c6979-39a7-48fa-ae14-7ae2268282a9" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

From the script, it can be seen that first it will read test.txt file that was dropped previously. After reading the content of test.txt, it will generate array of characters using StringSplit function and saved them to variable $a.

The content of test.txt can be seen below.

{{< image src="https://github.com/user-attachments/assets/399e68d4-39df-4337-a508-9d581b613f43" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The content of test.txt will be used as dictionary to resolve the values of $a[0x??].

- Example: $a[0x3a] = 9, $a[0x6] = 0, $a[0x3e]= E, etc.

Using the above concept, the script can be de-obfuscated. We had written a python script employing that concept and successfully managed to de-obfuscate the script. The script can be found in the [Github page](https://github.com/0x4P3/Config-Extractor/blob/main/DarkGate/Autoit%20(.au3)%20Decryptor/AutoitDecryptor.py).

{{< image src="https://github.com/user-attachments/assets/b082a1e2-ebf6-49fd-960c-14b012836f3e" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### Autoit3 Process Injection

The de-obfuscated script from above can be seen below.

{{< image src="https://github.com/user-attachments/assets/ef0ed137-1bb3-4188-911d-9d930723e3bb" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

From the script, it can be seen that all the hex values are concatenated into a variable $bzxrgjfo. This could potentially be another payload. We will analyze it later.

After that, there is check for C:\ProgramData\Sophos directory. And if that directory does not exist, it calls VirtualProtect to modify memory protection of $bzxrgjfo to 0x40 (PAGE_EXECUTE_READWRITE). This is an evasion technique to not get flagged by Sophos.

Then the payload is copied into DLL structure and is injected by calling EnumWindows. Through this, the payload is injected and executed.

Lets now focus on the payload. With the help of Cyberchef, the payload was decrypted which revealed an 32-bit executable as can be seen below.

{{< image src="https://github.com/user-attachments/assets/a4252e2b-75b0-47fe-9664-fcc84ea2d713" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

### Fifth Stager

#### Decrypting Darkgate Loader Autoit (.a3x) Script

The junk code above ‘MZ’ of above decrypted executable was removed to fix the executable and loaded in IDA for analysis. It was found that this executable searches for script.a3x script and locate the payload marked by ‘VzXLKSZE’ under the script.a3x script. Then the payload is decrypted with XOR operation and later mapped and executed.

{{< image src="https://github.com/user-attachments/assets/b1437121-b2b9-4fd1-8f08-39c703f63c33" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The payload is marked by ‘VzXLKSZE’ under script.a3x as can be seen below.

{{< image src="https://github.com/user-attachments/assets/1dae9c60-48e2-4b00-99ca-f407a485bb03" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

Under the xorDecrypt() function, it uses the ‘VzXLKSZE’ to generate new XOR key. Using the new XOR key, the payload is decrypted. The decrypted payload is then executed later.

{{< image src="https://github.com/user-attachments/assets/755c1053-f412-4025-ab6b-900f31d34963" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

I have written the loader decryption script to get the final decrypted payload which is in the [Github page](https://github.com/0x4P3/Config-Extractor/blob/main/DarkGate/DarkGate%20XOR%20Decryptor/DarkGateXORDecryptor.py).

{{< image src="https://github.com/user-attachments/assets/ac9ba354-ba27-4f7c-89ba-62f4c377ebb3" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

### Final Payload

#### Version

The above decrypted payload, which is the DarkGate was loaded in IDA for analysis. It was found that the version of this DarkGate was '6.1.9' as can be seen below. 

{{< image src="https://github.com/user-attachments/assets/c5b92a52-73d2-41bc-9359-1a234d4f444b" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### Dynamic DLL Loading

The DarkGate dynamically load DLLs and resolve APIs to hinder static detection and analysis as can be seen below.

{{< image src="https://github.com/user-attachments/assets/94525270-ea28-4936-9445-921f23f53447" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

<br>

#### Security Softwares Checks

DarkGate attempts to check major security softwares via their folders paths and their process names to evade detection as can be seen below.

{{< image src="https://github.com/user-attachments/assets/003924c5-72f3-4704-9bcb-9b1ba7bf608e" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The security software that DarkGate checks are listed below:

```
Bitdefender
Avast
Kaspersky
Nod32
Avira
Norton
Symantec
Trend Micro
McAfee
SUPER AntiSpyware
Comodo
MalwareBytes
ByteFence
Search & Destroy
360 Total Security
Total AV
IObit Malware Fighter
Panda Security
Emsisoft
Quick Heal
F-Secure
Sophos
G DATA
Windows Defender
```

<br>

#### Decrypt Configuration

The DarkGate decrypt its configuration via XOR encryption. The XOR decryption mechanism is similar to that of decrypting DarkGate from DarkGate loader (script.a3x) as covered in above section. The only difference is that instead of using ‘VzXLKSZE’ as marker and to generate XOR key, ‘ckcilIcconnh’ was used as can be seen below. 

{{< image src="https://github.com/user-attachments/assets/2e3f134c-3822-4f84-b2e3-5aae81ff59b9" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The same XOR decryption script, which is in the [Github page](https://github.com/0x4P3/Config-Extractor/blob/main/DarkGate/DarkGate%20XOR%20Decryptor/DarkGateXORDecryptor.py) was used to decrypt the DarkGate configuration.

{{< image src="https://github.com/user-attachments/assets/9c9a4766-be4c-4006-840a-54c28db0f9ec" caption="" alt="" height="" width="" position="center" command="fit" option="" class="img-fluid" title="" >}}

The decrypted reable configuration is shown below.

```
prodomainnameeforappru.com|
8=No
11=DarkGate
12=R0ijS0qCVITtS0e6xeZ
13=6
14=Yes
15=443
1=Yes
3=Yes
4=Yes
18=50
6=Yes
7=No
19=7000
5=Yes
21=No
22=Yes
23=No
25=admin888
26=No
27=VzXLKSZE
28=No
29=1
tabla=(nq]N*0CV3&ReMOtJ}UaD{W Zxb8uldY"SK2T1rspj$oIFfGB=QL65.Hci9wz)Em4ghAy,k7[XvP
```
